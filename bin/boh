#!/usr/bin/env node

var path = require("path"),
	fs = require("fs"),
	async = require("async"),
	colors = require("colors"),
	chokidar = require("chokidar"),
	debug = require("debug")("boh:cli"),
	boh = require("../"),
	config = require("../package.json"),
	argv = process.argv.slice(2);

// Tab character
const TAB = "    ";
const BOH = "boh".bgBlack.blue.bold;

/*
 * Print out the help.
 */
var help = log.bind(null, function() {/*
boh - a simple build tool.

    <dir>                   Build the files in <dir> (optional).
      --include <paths>     Paths to include in index.
      --ignore <paths>      Paths to ignore in index.
    watch <dir>             Watch <dir> (optional) for file changes 
    help                    Print this help screen

    --index <dir>           Print the boh index of a directory.
*/}.toString().replace(/(^[^\n]*\n)|(\n\*\/\})/g, ""));

if(require.main === module) {
	program({
		"--version": log.bind(null, config.version),

		"--watch": watch,

		"--help": help,

		"--index": index
	}, run);
}

var events = {
	add: function(index, dir, file, callback) {
		index.addFile(file, function(err) {
			if(err) log(index.relative(file) + " ✘".red + " -> " + "Error: ".red + err.message + "\n");
			else {
				log("New file".green + " %s add to the index.", file);
				if(callback) callback();
			}
		});
	},

	addDir: function(index, dir, directory, callback) {
		index.addDirectory(directory);
		if(callback) callback();
	},

	change: function(index, dir, file, callback) {
		// Re-add the file in case the rules change
		index.addFile(file, function(err) {
			if(err) log(index.relative(file) + " ✘".red + " -> " + "Error: ".red + err.message + "\n");
			else {
				log("%s changed.", file.yellow);

				// Find the rules associated with that file and run them
				var rules = index.getRulesForFile(file);

				if(rules && rules.length) 
					// And build the select rules.
					buildReporter(option("-v"), dir).buildRules(index, rules, callback);
			}
		});
	}
}

/**
 * Start boh watching a directory.
 * @param  {String} dir The directory to watch in (optional).
 */
function watch(dir) {
	if(!dir) dir = process.cwd();

	async.waterfall([
		run.bind(null, dir),

		function(index, callback) {
			var cwd = path.relative(process.cwd(), dir);
			log("\n" + BOH + " is watching for changes in %s.", (!cwd ? "the current directory" : cwd).magenta);

			// Create the chokidar watcher
			var watcher = chokidar.watch(index.root, { 
				ignoreInitial: true,
				ignored: index.ignored, 
				persistent: true 
			});

			// Bind the events
			Object.keys(events).forEach(function(event) {
				debug("Binding filesystem event %s.", event);
				watcher.on(event, events[event].bind(null, index, dir));
			});
		}
	])
}

/**
 * Run boh in a directory.
 * @param  {String} dir The directory to run boh in.
 */
function run(dir, callback) {
	// Get the directory from the first argument
	dir = relative(!isOption(dir) ? dir : null);

	var _index;

	async.waterfall([
		// Stat the input
		fs.stat.bind(fs, dir),

		// Make sure we have a directory
		function(stat, callback) {
			if(stat.isDirectory()) callback(null, stat);
			else fail("%s not a directory.", dir);
		},

		// Output the directory
		function(stat, callback) {
			var cwd = path.relative(process.cwd(), dir);
			logRaw("Running " + BOH + " in " + (!cwd ? "the current directory" : cwd).magenta);
			callback();
		},

		// Find installed plugins
		boh.findPlugins.bind(null),

		function(plugins, callback) { 
			// No plugins, exit
			if(plugins.length === 0) {
				logRaw(".\n");
				return callback();
			}

			logRaw(" with plugins: ")
			var emitter = boh.requirePlugins(plugins, function(err) {
				if(err) callback(err);
				else logRaw("\n"), callback();
			});

			emitter.on("plugin:loaded", function(plugin) { 
				logRaw((plugin + " ✓ ").green); 
			});

			emitter.on("plugin:error", function(plugin) { 
				logRaw((plugin + " ✘ ").red); 
			});
		},

		function(callback) {
			var options = {}, value;

			// Ignore option. Supports micromatch (https://www.npmjs.com/package/micromatch)
			if(value = option("--ignore")) options.ignore = value.split(",").map(function(p) { return relative(p.trim()); });

			callback(null, options);
		},

		// Build the index
		function(options, callback) {
			var indexer = new boh.Indexer();

			indexer.on("error:index", function(err) {
				log(indent(1, relative(err.file).yellow + " -> " + "Index Error".red));
				log(indent(2, err.message));
			});

			indexer.index(dir, options, callback);
		},

		function(index, callback) {
			// Save a reference to the index
			_index = index;

			// Create the new reporter and build!
			buildReporter(option("-v"), dir).build(index, callback);
		}
	], function(err) {
		if(callback) callback(err, _index);
		else if(err && err.code === "ENOENT") fail("%s does not exist.", dir);
		else if(err) fail(err);
	})
}

/**
 * Return the path of a directory relative to the cwd.
 * @param  {String} dir Path. (optional, returns cwd otherwise);
 * @return {[type]}     [description]
 */
function relative(dir) {
	if(!dir) return process.cwd();
	else if(dir) return path.resolve(process.cwd(), dir);
}

/**
 * Print out the index of the directory.
 * @param  {String} dir Path.
 */
function index(dir) {
	var indexer = new boh.Indexer();
	indexer.index(relative(dir), function(err, index) {
		if(err) fail(err);
		else index.toString().split("\n").forEach(function(line) { log(line); });
	});
}

/**
 * Load all the plugins from the current directory.
 * @param  {Function} callback 
 */
function loadPlugins(callback) {
	async.waterfall([
		// Find the plugins
		boh.findPlugins.bind(boh),
	], callback);
}

/**
 * Log something to stdout.
 */
function log() {
	console.log.apply(console, arguments);
}

/**
 * Log raw to stdout.
 */
function logRaw() {
	process.stdout.write.apply(process.stdout, arguments);
}

/**
 * Indent a multi line string.
 * @param  {Number} level  Indentation level.
 * @param  {String} string 
 * @return {String}        Indented string.
 */
function indent(level, string) {
	var indentation = ""; 
	for(var i = 0; i < level; i++) indentation += TAB;
	return string.split("\n").map(function(line) {
		return indentation + line;
	}).join("\n");
}

/**
 * The program fails.
 * @param  {Error} err 
 */
function fail() {
	var args = Array.prototype.slice.call(arguments);

	if(typeof args[0] === "string") args[0] = "Error: ".red + args[0];

	console.log.apply(console, args);

	process.exit();
}

/**
 * Create a program that matches arguments.
 * @param  {Object} spec { regex: callback }
 * @param  {Function} defaultAction
 */
function program(spec, defaultAction) { 
	var command = argv[0];

	if((!command || !Object.keys(spec).some(function(regex) {
		var match = command.match(new RegExp(regex));
		if(match != null && command == match[0]) {
			spec[regex].apply(null, argv.slice(1));
			return true;
		}
	})) && defaultAction) defaultAction.apply(null, argv); 
}

/**
 * Return a value for an option passed as a parameter
 * @param  {String} name The name of the option e.g. version
 * @param  {String} shortname The shortname of the options e.g. v (for version)
 * @return {String}      Value.
 */
function option(name) {
	var args = Array.prototype.slice.call(arguments),
		argv = Array.isArray(args[args.length - 1]) ? args.pop().join(" ") : process.argv.join(" "),
		regex = "(?:" + args.join("|") + ")(?:\\s+|$)";

	if(argv.match(new RegExp(regex + "\"([^\"]+)\""))) return RegExp.$1;
	else if(argv.match(new RegExp(regex + "([^\\s]+)"))) return RegExp.$1;
	else if(argv.match(new RegExp(regex))) return true;
}

/**
 * Test if a string is an option.
 * @param  {String}  string 
 * @return {Boolean}        
 */
function isOption(string) {
	return typeof string === "string" && !!string.match(/^--?\w+$/);
}

/**
 * Create a new builder reporter.
 * @return {boh.Builder} 
 */
function buildReporter(verbose, dir) {
	// Create the build reporter
	var builder = new boh.Builder();

	builder.on("rule", function(plugin, rule) {
		var descriptor = path.relative(dir, rule.file).yellow + ":" + rule.name.cyan,
			x, y;

		plugin.on("start", function() {
			logRaw("\n" + TAB + descriptor + (verbose ? "\n" : ""));
		});

		if(verbose) plugin.on("log", log.bind(null, TAB + TAB));

		plugin.on("error", function(err) {
			logRaw((verbose ? "\n" + TAB + descriptor : "") + " ✘".red + " -> " + "Error: ".red + err.message + "\n");
		});

		plugin.on("finish", function(rule) {
			logRaw((verbose ? TAB + descriptor : "") + (" ✓ (" + rule.duration + "ms)").green + "\n");

			if(typeof rule.output === "string") rule.output.split("\n").filter(function(line) {
				return !!line;
			}).map(function(line) {
				return TAB + TAB + "-> ".red + line;
			}).forEach(function(line) { log(line) });
		});
	});

	var errors = [];
	builder.on("error", function(err, rule) {
		var descriptor = path.relative(dir, rule.file).yellow + ":" + rule.name.red;

		switch(err.code) {
			case "PLUGIN_NOT_FOUND":
				log("\n" + TAB + descriptor + " -> Plugin " + rule.name.red + " not found: Try running " + ("npm install --save-dev boh-" + rule.name).blue);
			break;
		}

		errors.push([err, rule]);
	})

	builder.on("finish", function() {
		log("\nBuild complete " + (errors.length ? ("with " + errors.length + " error" + (errors.length > 1 ? "s" : "")).red : "successfully".green) + ".")
	});

	return builder;
}

// Exporting for testing.
module.exports = {
	option: option,
	events: events
};
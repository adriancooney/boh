#!/usr/bin/env node

var path = require("path"),
	fs = require("fs"),
	async = require("async"),
	colors = require("colors"),
	boh = require("../"),
	config = require("../package.json"),
	argv = process.argv.slice(2);

// Tab character
const TAB = "    ";

/*
 * Print out the help.
 */
var help = log.bind(null, function() {/*
boh - a simple build tool.

    <dir>                   Build the files in <dir> (optional).
      --include <paths>     Paths to include in index.
      --ignore <paths>      Paths to ignore in index.
    watch <dir>             Watch <dir> (optional) for file changes 
    help                    Print this help screen

    --index <dir>           Print the boh index of a directory.
*/}.toString().replace(/(^[^\n]*\n)|(\n\*\/\})/g, ""));

if(require.main === module) {
	program({
		"--version": log.bind(null, config.version),

		"watch": watch,

		"help|--help": help,

		"--index": index
	}, run);
}

/**
 * Start boh watching a directory.
 * @param  {String} dir The directory to watch in (optional).
 */
function watch(dir) {
	if(!dir) dir = process.cwd();
	log("boh is watching for changes in %s.", dir);
}

/**
 * Run boh in a directory.
 * @param  {String} dir The directory to run boh in.
 */
function run(dir) {
	// Get the directory from the first argument
	dir = relative(!isOption(dir) ? dir : null);

	async.waterfall([
		// Stat the input
		fs.stat.bind(fs, dir),

		// Make sure we have a directory
		function(stat, callback) {
			if(stat.isDirectory()) callback(null, stat);
			else fail("%s not a directory.", dir);
		},

		// Output the directory
		function(stat, callback) {
			var cwd = path.relative(process.cwd(), dir);
			logRaw("Running boh in " + (!cwd ? "the current directory" : cwd).magenta);
			callback();
		},

		// Find installed plugins
		boh.findPlugins.bind(null),

		function(plugins, callback) { 
			// No plugins, exit
			if(plugins.length === 0) {
				logRaw(".\n");
				return callback();
			}

			logRaw(" with plugins: ")
			var emitter = boh.requirePlugins(plugins, function(err) {
				if(err) callback(err);
				else logRaw("\n"), callback();
			});

			emitter.on("plugin:loaded", function(plugin) { 
				logRaw((plugin + " ✓ ").green); 
			});

			emitter.on("plugin:error", function(plugin) { 
				logRaw((plugin + " ✘ ").red); 
			});
		},

		function(callback) {
			var options = {}, value;

			// Ignore option. Supports micromatch (https://www.npmjs.com/package/micromatch)
			if(value = option("--ignore")) options.ignore = value.split(",").map(function(p) { return relative(p.trim()); });

			callback(null, options);
		},

		// Build the index
		function(options, callback) {
			var indexer = new boh.Indexer();

			indexer.index(dir, options, callback);
		},

		function(index, callback) {
			var verbose = option("-v");

			// Log the index if verbose
			if(verbose) log(index.toString());

			// Start the build process
			var builder = new boh.Builder();

			builder.on("rule", function(plugin, rule) {
				var descriptor = path.relative(dir, rule.file).yellow + ":" + rule.name.cyan,
					x, y;

				plugin.on("start", function() {
					logRaw("\n" + TAB + descriptor + (verbose ? "\n" : ""));
				});

				if(verbose) plugin.on("log", log.bind(null, TAB + TAB));

				plugin.on("error", function(err) {
					logRaw((verbose ? "\n" + TAB + descriptor : "") + " ✘".red + " -> " + "Error: ".red + err.message + "\n");
				});

				plugin.on("finish", function(rule) {
					logRaw((verbose ? "\n" + TAB + descriptor : "") + (" ✓ (" + rule.duration + "ms)").green + "\n");

					if(typeof rule.output === "string") rule.output.split("\n").filter(function(line) {
						return !!line;
					}).map(function(line) {
						return TAB + TAB + "-> ".red + line;
					}).forEach(function(line) { log(line) });
				});
			});

			var errors = [];
			builder.on("error", function(err, rule) {
				var descriptor = path.relative(dir, rule.file).yellow + ":" + rule.name.red;

				switch(err.code) {
					case "PLUGIN_NOT_FOUND":
						log("\n" + TAB + descriptor + " -> Plugin " + rule.name.red + " not found: Try running " + ("npm install --save-dev boh-" + rule.name).blue);
					break;
				}

				errors.push([err, rule]);
			})

			builder.on("finish", function() {
				log("\nBuild complete " + (errors.length ? ("with " + errors.length + " error" + (errors.length > 1 ? "s" : "")).red : "successfully".green) + ".")
			});

			// Start the build!
			builder.build(index, callback);
		}
	], function(err) {
		if(err && err.code === "ENOENT") fail("%s does not exist.", dir);
		else if(err) fail(err);
	})
}

/**
 * Return the path of a directory relative to the cwd.
 * @param  {String} dir Path. (optional, returns cwd otherwise);
 * @return {[type]}     [description]
 */
function relative(dir) {
	if(!dir) return process.cwd();
	else if(dir) return path.resolve(process.cwd(), dir);
}

/**
 * Print out the index of the directory.
 * @param  {String} dir Path.
 */
function index(dir) {
	var indexer = new boh.Indexer();
	indexer.index(relative(dir), function(err, index) {
		if(err) fail(err);
		else index.toString().split("\n").forEach(function(line) { log(line); });
	});
}

/**
 * Load all the plugins from the current directory.
 * @param  {Function} callback 
 */
function loadPlugins(callback) {
	async.waterfall([
		// Find the plugins
		boh.findPlugins.bind(boh),
	], callback);
}

/**
 * Log something to stdout.
 */
function log() {
	console.log.apply(console, arguments);
}

/**
 * Log raw to stdout.
 */
function logRaw() {
	process.stdout.write.apply(process.stdout, arguments);
}

/**
 * The program fails.
 * @param  {Error} err 
 */
function fail() {
	var args = Array.prototype.slice.call(arguments);

	if(typeof args[0] === "string") args[0] = "Error: ".red + args[0];

	console.log.apply(console, args);

	process.exit();
}

/**
 * Create a program that matches arguments.
 * @param  {Object} spec { regex: callback }
 * @param  {Function} defaultAction
 */
function program(spec, defaultAction) { 
	var command = argv[0];

	if((!command || !Object.keys(spec).some(function(regex) {
		var match = command.match(new RegExp(regex));
		if(match != null && command == match[0]) {
			spec[regex].apply(null, argv.slice(1));
			return true;
		}
	})) && defaultAction) defaultAction.apply(null, argv); 
}

/**
 * Return a value for an option passed as a parameter
 * @param  {String} name The name of the option e.g. version
 * @param  {String} shortname The shortname of the options e.g. v (for version)
 * @return {String}      Value.
 */
function option(name) {
	var args = Array.prototype.slice.call(arguments),
		argv = Array.isArray(args[args.length - 1]) ? args.pop().join(" ") : process.argv.join(" "),
		regex = "(?:" + args.join("|") + ")(?:\\s+|$)";

	if(argv.match(new RegExp(regex + "\"([^\"]+)\""))) return RegExp.$1;
	else if(argv.match(new RegExp(regex + "([^\\s]+)"))) return RegExp.$1;
	else if(argv.match(new RegExp(regex))) return true;
}

/**
 * Test if a string is an option.
 * @param  {String}  string 
 * @return {Boolean}        
 */
function isOption(string) {
	return typeof string === "string" && !!string.match(/^--?\w+$/);
}

module.exports = {
	option: option
};